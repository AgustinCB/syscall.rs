#!/usr/bin/env python3

import re
import tempfile
import subprocess
import sys

from typing import Iterable, Set

linux_path = '.'

SIMPLE_MATH = re.compile('\((\d+)\s*\+\s*(\d+)\)')

def load_table(path: str, arches: Set[str]):
    with open('{}/{}'.format(linux_path, path)) as f:
        for line in f:
            line = line.strip()
            if line.startswith('#') or not line:
                continue
            nr, arch, name = line.split('\t', 4)[0:3]
            if arch in arches:
                yield (name, int(nr))

def eval_expr(expr: str) -> int:
    ma = SIMPLE_MATH.match(expr)
    if ma:
        return int(ma.group(1)) + int(ma.group(2))
    raise Exception('"{}" looks like an expression, but not a supported one'.format(expr))


def load_headers(names: Iterable[str], arch: str, extra: str = ''):
    with tempfile.NamedTemporaryFile(mode='w+', suffix='.h') as f:
        f.write(extra)
        f.write('\n')
        f.write('#include <asm/unistd.h>\n')
        for name in names:
            f.write('gen_nr {0} __NR_{0}\n'.format(name))
        f.flush()
        lines = subprocess.check_output(['gcc', '-nostdinc',
            '-I', '{}/arch/{}/include/uapi'.format(linux_path, arch),
            '-I', '{}/include'.format(linux_path),
            '-P', # don't include line number markers, which make the output annoying to parse
            '-E', # only preprocess, don't compile
            f.name]).decode('utf-8').split('\n')

    for line in lines:
        if not line.startswith('gen_nr '):
            continue
        _, name, nr = line.split(' ', 2)
        if nr.startswith('__NR_'):
            # unsupported on this arch
            continue
        if nr.startswith('('):
            nr = eval_expr(nr)
        yield (name, int(nr))


def main():
    names = set(x.group(1) for x in re.finditer('\\b__NR_([a-z0-9_]+)\\b',
        subprocess.check_output(['git', '--no-pager', 'grep', '__NR_'], cwd=linux_path)
            .decode('utf-8')))
    if len(names) < 380:
        print("didn't find anywhere near enough syscalls; hack must have failed")
        sys.exit(1)
    numbers = {
            'linux-aarch64': dict(load_headers(names, 'arm64')),
            'linux-armeabi': dict(load_table('arch/arm/tools/syscall.tbl', {'common', 'eabi'})),
            'linux-mips': dict(load_headers(names, 'mips',
                '#define _MIPS_SIM _MIPS_SIM_ABI32')),
            'linux-mips64': dict(load_headers(names, 'mips',
                '#define _MIPS_SIM _MIPS_SIM_ABI64')),
            'linux-powerpc': dict(load_headers(names, 'powerpc',
                '#undef __arch64__')),
            'linux-powerpc64': dict(load_headers(names, 'powerpc',
                '#define __arch64__ 1\n#define __powerpc64__')),
            'linux-sparc64': dict(load_headers(names, 'sparc')),
            'linux-x86': dict(load_table('arch/x86/entry/syscalls/syscall_32.tbl', {'i386'})),
            'linux-x86_64': dict(load_table('arch/x86/entry/syscalls/syscall_64.tbl', {'common', '64'})),
            }

    for arch, nums in numbers.items():
        if not nums:
            continue
        with open('../src/platform/{}/nr.rs'.format(arch), 'w') as f:
            f.write('/* automatically generated by nr_from_src.py */\n\n')
            for name, nr in sorted(nums.items()):
                f.write('pub const {}: usize = {};\n'.format(name.upper(), nr))

if '__main__' == __name__:
    if len(sys.argv) > 1:
        linux_path = sys.argv[1]
    main()

